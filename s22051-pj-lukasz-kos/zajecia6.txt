/* 
Zajęcia 6

Obsługa sygnałów
W pierwszej kolejności należy zaimplementować bibliotekę <signal.h>. Jednakże...
Z racji tego, że część funkcji tej biblioteki (np. typ sigset_t czy struktura sigaction) nie stanowi standartu języka ANSI C, 
to należy je zdefiniować przy użyciu makra. Przed 'blokiem' #include należy dopisać 
*/
#define _POSIX_SOURCE
/*
Co pozwoli na użycie funkcjonalności standardu POSIX w wersji 1. Oczywiście można to zrobić na wiele sposobów, po szczegóły odsyłam tu:
https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html#Feature-Test-Macros

Generalnie sygnał jest to przerwanie dostarczone do procesu. Systemy operacyjne używają sygnałów do raportowania wyjątkowych sytuacji np. błędów, 
eventów czy próśb. 
Linux umożliwia przechwycenie sygnału oraz zmianę jego standardowego zachowania poprzez użycie funkcji signal lub sigaction.
sigaction ma to samo zastosowanie co funkcja signal, aczkolwiek pozwala na znacznie większą kontrolę poprzez zdefiniowanie flag 
w strukturze (SIC) sigaction.

struct sigaction {
	sighandler_t sa_handler - tutaj ustawiasz nową procedurę obsługi. 
								Domyślne to: SIG_DFL (signal default, domyślna obsługa) lub SIG_IGN (ignorowanie sygnału).
								Można również ustawić wskaźnik na własną funkcję obsługującą sygnał.
	sigset_t sa_mask - zbiór sygnałów, które będą przechwytywane PONAD TO co zdefiniujemy w funkcji sigaction. Stąd nazwa maska.
						Jako, że chcemy przechwycić tylko jeden sygnał, to ta maska może pozostać pusta. 
						Puste maski generuje się funkcją int sigemptyset(sigset_t *set).
	int sa_flags - ustanawia flagi do kontroli sygnału, szczegóły w linku. Na nasze potrzeby ustawiamy 0.
					https://www.gnu.org/software/libc/manual/html_node/Flags-for-Sigaction.html#Flags-for-Sigaction
}

A teraz sama funkcja sigaction
*/
int sigaction (int signum, const struct sigaction *restrict action, strict sigaction *restrict old-action)
/* 
signum - określa sygnał, który chcemy przechwycić. Lista sygnałów pod linkiem
            https://man7.org/linux/man-pages/man7/signal.7.html
action - struktura, w której zdefiniowaliśmy nowe procedury obsługi sygnału, maskę i flagi
old-action - zwraca DOMYŚLNĄ strukturę obsługi sygnału. Nie potrzebujemy tego więc ustawiamy NULL.

Po tak zdefiniowanej strukturze sigaction oraz użytej funkcji sigaction, należy przede wszystkim pamiętać, że napisaną przez nas funkcję do obsługi sygnału, 
deklarujemy w strukturze sigaction przekazując wskaźnik do funkcji pod element sa_handler. 


Gniazda
Gniazda to uogólniony kanał komunikacji międzyprocesorowej. Podobnie jak potok, gniazdo jest reprezentowane jako deskryptor pliku. 
Gniazda obsługują komunikację między niepowiązanymi procesami, a nawet między procesami działającymi na różnych komputerach, 
które komunikuja się przez sieć. 

Aby moć zastosować funkcje związane z gniazdami oraz stworzyć gniazdo, należy zaimplementować w kodzie bibliotekę <sys/socket.h>
Gniazdo tworzymy funkcją socket
int socket (int namespace, int style, int protocol)
	namespace : PF_LOCAL (lokalna przestrzeń nazw) lub PF_INET (internetowa przestrzeń nazw)
	style : rodzaje komunikacji
		int SOCK_STREAM - podobny do potoku, połączenie ze zdalnym gniazdem i pewny, ale wolniejszy przesył informacji
		int SOCK_DGRAM - datagram, przesyła dane w formie pakietów na zadany adres, nie bacząc na kolejność przesyłu. Jeśli pakiet nie został dostarczony 
		w całości jest wysyłany jeszcze raz. Szybki, ale niedokładny sposób przesyłu danych.
	protocol : 0

Gdy skończyłeś korzystać z gniazda, możesz go zamknąć funkcją close. 
Można ustanawiać pary gniazd za pomocą funkcji socketpair. Ich działanie jest bardzo podobne do potoku i kolejki FIFO, z tą różnicą, że 
komunikacja jest dwukierunkowa.

Tworzenie połączenie jest asymetryczne: jedna strona (klient) żąda połączenia, podczas gdy druga strona (serwer) tworzy gniazdo i czeka 
na żądanie połączenia. Do ustanawiania połączenia można wykorzystać funkcję connect
int connect (int socket, struct sockaddr *addr, socklen_t length)
	
Nazwa gniazda to adres. Nowo stworzone gniazdo (przy pomocy funkcji socket) nie ma adresu. Bez adresu inne procesy nie ustalą połączenia z gniazdem. 
Aby przypisać gniazdu adres należy użyć funkcji bind, przekazując ją w formie wskaźnika do struktury sockaddr.

Aby użyć typów danych niezbędnych do zdefiniowania adresu gniazda w internetowej przestrzenii nazw należy zaimplementować bibliotekę <netinet/in.h>
i użyć jednego z dwóch struktur, opisujących adres w zależności od protokołu

struct sockaddr_in {
	sa_family_t sin_family 		- format adresu, AF_INET
	struct in_addr sin_addr 		- adres IPv4
	unsigned short int sin_port 	- numer portu
}

Aby przypisać gniazdo do adresu należy użyć funkcji bind:
int bind (int socket, struct sockaddr *addr, socklen_t length)

Aby sprawdzić adres gniazda internetowego (przeczytać go) należy użyć funkcji getsockname
int getsockname (int socket, struct sockaddr *addr, socklen_t *length-ptr)


Aby użyć funkcji do zarządzania internetowymi adresami należy zaimplementować funkcję <arpa/inet.h>. Lista tych funkcji znajduje się poniżej:
https://www.gnu.org/software/libc/manual/html_node/Host-Address-Functions.html

Nazwy hosta można zdefiniować poprzez funkcje z biblioteki <netdb.h>. Lista jest tutaj:
https://www.gnu.org/software/libc/manual/html_node/Host-Names.html

Adres gniazda w internetowej przestrzenii nazw składa się z adresu internetowego urządzenia oraz numeru portu, który rozróżnia gniazda dla 
danego urządzenia. Zakres portów to 16 bit (0 - 65535). Standardowe serwery mają zarezerwowany zakres portów.

Każdy interfejs sieciowy ma nazwę. Funkcje związane z interfejsami znajdują się w bibliotece  <net/if.h> i można ogarnąć je tu:
https://www.gnu.org/software/libc/manual/html_node/Interface-Naming.html#Interface-Naming


Aby serwer mógł zaakceptować połączenie na gnieździe, najpierw trzeba będzie zrobić nasłuch na gniazdo. Do tego służy funkcja listen. 
Następnie można zaakceptować nadchodzące połączenie funkcją accept. accept tworzy nowe gniazdo do komunikacji. Natomiast pierwotne gniazdo 
służy do nasłuchu kolejnych, pozostałych połączeń.
int listen (int socket, int n), n określa długość kolejki nadchodzących połączeń
int accept (int socket, struct sockaddr *addr, socklen_t *length_ptr), funkcja zwraca deskryptor do nowego gniazda, które stanowi część połączenia

getpeername zwraca adres gniazda, do którego jest podłączone dane gniazdo.

Do przesyłania danych możesz użyć funkcji send lub write. write nie ma argumentu flags.
ssize_t send (int socket, const void *buffer, size_t size, int flags)
int write(int file_descriptor, char *buffer, int size)

Do odbierania danych służy recv lub read (poodobnie jak wyżej).
ssize_t recv (int socket, void *buffer, size_t size, int flags)
int read(int file_descriptor, char *buffer, int size)


W skrócie po stronie klienta należy:
1. Utworzyć gniazdo przy pomocy socket()
2. Połączyć gniazdo z adresem serwera używając connect()
3. Wysyłać i otrzymywać dane poprzez write() i read() 

Po stronie serwera należy:
1. Utworzyć gniazdo przy pomocy socket()
2. Połączyć gniazdo z adresem używając bind(). 
3. Nasłuchiwać połączeń przy użyciu listen()
4. Akceptować połączenia przy użyciu accept()
5. Wysyłać i otrzymywać dane poprzez write() i read() 
*/
